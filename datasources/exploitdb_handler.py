import csv
import logging
from dateutil import parser

from handlers import utils
from handlers.config_handler import ConfigHandler
from handlers.logger_handler import Logger
from handlers.mongodb_handler import MongoDBHandler

def singleton(cls):
    """A decorator function that implements the Singleton design pattern.
    
    Args:
        cls (type): The class to be transformed into a Singleton.
    
    Returns:
        function: A wrapper function that ensures only one instance of the class is created.
    
    """
    instances = {}

    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]

    return get_instance

@singleton
class ExploitdbHandler:

    LOG_PREFIX = f"[{chr(int('eaaf', 16))} ExploitDB]"

    def __init__(self, mongo_handler, config_file='configuration.ini', logger=None):
        """Initialize the ExploitDBHandler.
        
        Args:
            mongo_handler (object): Handler for MongoDB operations.
            config_file (str, optional): Path to the configuration file. Defaults to 'configuration.ini'.
            logger (object, optional): Logger object for logging. If None, a default logger will be created.
        
        Returns:
            None
        
        Raises:
            ConfigurationError: If there's an issue with reading or parsing the configuration file.
        """
        config_handler = ConfigHandler(config_file)

        exploitdb_config = config_handler.get_exploitdb_config()
        self.url = exploitdb_config.get('url', 'https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv?ref_type=heads')
        self.save_data = config_handler.get_boolean('cvemate', 'save_data', False)

        self.mongodb_handler = mongo_handler

        self.logger = logger.bind(prefix=self.LOG_PREFIX) if logger else logger.bind(prefix=self.LOG_PREFIX)


    def init(self):
        """Initialize and update the ExploitDB data.
        
        This method checks for updates in the ExploitDB repository, downloads the latest data if necessary,
        processes the CSV file to extract CVE information, and updates the MongoDB database.
        
        Args:
            self: The instance of the class containing this method.
        
        Returns:
            None
        
        Raises:
            None explicitly, but may raise exceptions from called methods or libraries.
        
        Side Effects:
            - Downloads a CSV file from ExploitDB if an update is available.
            - Updates the MongoDB database with new exploit information.
            - Logs various information about the update process.
        """
        exploitdb_status = self.mongodb_handler.get_source_status('exploitdb')
        last_git_commit = utils.get_gitlab_latest_commit_date('https://gitlab.com/api/v4', 'exploit-database/exploitdb', 'files_exploits.csv')

        # Convert last_git_commit to a date object
        last_git_commit = parser.isoparse(last_git_commit).date()

        # Check if exploitdb_status is available and its last_git_commit
        if not exploitdb_status or parser.isoparse(exploitdb_status['source_last_update']).date() < last_git_commit:

            # Call the new download_file method
            csv_data = utils.download_file(self.url, save_path='data/exploitdb.csv' if self.save_data else None, logger=self.logger)

            # Log the number of exploits and size of the file
            num_exploits = len(csv_data.splitlines()) - 1  # Subtract 1 for the header row
            file_size = len(csv_data.encode('utf-8'))  # Size in bytes
            self.logger.info(f"Downloaded {num_exploits} exploits, file size: {file_size} bytes")

            # Initialize an empty list for the results
            results = []

            # Initialize a counter for CVE codes
            cve_count = 0

            # Process the CSV data
            lines = csv_data.splitlines()
            reader = csv.DictReader(lines)
            for row in reader:
                codes = row.get('codes', '').split(';')
                for code in codes:
                    if code.startswith('CVE-'):
                        # Exclude the 'codes' column and add the data to the results
                        row_copy = row.copy()
                        row_copy.pop('codes', None)
                        results.append({'id': code, 'exploitdb': row_copy})
                        self.logger.debug(f"CVE code {code} found for id {row['id']}. Corresponding data:\n{row_copy}")
                        cve_count += 1

            # Log the number of CVE codes found
            self.logger.info(f"Total number of CVE codes found: {cve_count}")

            result = self.mongodb_handler.queue_request('cve', results, update=True, key_field='id')
            self.logger.info(f"mongodb query: {result}")

            self.mongodb_handler.update_source_status('exploitdb', {'source_last_update':last_git_commit.isoformat()})
        else:
            # Skip if the condition is not met
            self.logger.info(f"Skipping update, source_last_update: {exploitdb_status['source_last_update']}")
