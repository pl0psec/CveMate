import csv
import logging
from dateutil import parser

from handlers import utils
from handlers.config_handler import ConfigHandler
from handlers.logger_handler import Logger
from handlers.mongodb_handler import MongoDBHandler

def singleton(cls):
    instances = {}

    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]

    return get_instance

@singleton
class ExploitdbHandler:

    def __init__(self, mongo_handler, config_file='configuration.ini', logger=None):
        self.banner = f"{chr(int('EAD3', 16))} {chr(int('eaaf', 16))} Exploit-DB"
        config_handler = ConfigHandler(config_file)

        exploitdb_config = config_handler.get_exploitdb_config()
        self.url = exploitdb_config.get('url', 'https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv?ref_type=heads')
        self.save_data = config_handler.get_boolean('cvemate', 'save_data', False)

        self.mongodb_handler = mongo_handler

        self.logger = logger or logging.getLogger()


    def init(self):
        print('\n'+self.banner)

        exploitdb_status = self.mongodb_handler.get_source_status('exploitdb')
        last_git_commit = utils.get_gitlab_latest_commit_date('https://gitlab.com/api/v4', 'exploit-database/exploitdb', 'files_exploits.csv')

        # Convert last_git_commit to a date object
        last_git_commit = parser.isoparse(last_git_commit).date()

        # Check if exploitdb_status is available and its last_git_commit
        if not exploitdb_status or parser.isoparse(exploitdb_status['source_last_update']).date() < last_git_commit:

            # Call the new download_file method
            csv_data = utils.download_file(self.url, 'data/exploitdb.csv', logger=self.logger)

            # Log the number of exploits and size of the file
            num_exploits = len(csv_data.splitlines()) - 1  # Subtract 1 for the header row
            file_size = len(csv_data.encode('utf-8'))  # Size in bytes
            self.logger.info(f"[{chr(int('eaaf', 16))} ExploitDB] Downloaded {num_exploits} exploits, file size: {file_size} bytes")

            # Initialize an empty list for the results
            results = []

            # Initialize a counter for CVE codes
            cve_count = 0

            # Process the CSV data
            lines = csv_data.splitlines()
            reader = csv.DictReader(lines)
            for row in reader:
                codes = row.get('codes', '').split(';')
                for code in codes:
                    if code.startswith('CVE-'):
                        # Exclude the 'codes' column and add the data to the results
                        row_copy = row.copy()
                        row_copy.pop('codes', None)
                        results.append({'id': code, 'exploitdb': row_copy})
                        self.logger.debug(f"[{chr(int('eaaf', 16))} ExploitDB] CVE code {code} found for id {row['id']}. Corresponding data:\n{row_copy}")
                        cve_count += 1

            # Log the number of CVE codes found
            self.logger.info(f"[{chr(int('eaaf', 16))} ExploitDB] Total number of CVE codes found: {cve_count}")

            result = self.mongodb_handler.queue_request('cve', results, update=True, key_field='id')
            self.logger.info(f"[{chr(int('eaaf', 16))} ExploitDB] mongodb query: {result}")

            self.mongodb_handler.update_source_status('exploitdb', {'source_last_update':last_git_commit.isoformat()})
        else:
            # Skip if the condition is not met
            self.logger.info(f"Skipping update, source_last_update: {exploitdb_status['source_last_update']}")
